# 58, 59, 60, 61, 62, 63 DOM - Document Object Model

- DOM is an organization chart created automatically by the browser
- DOM is generated by the browser
- The DOM is an API for the browser = Application Programming Interface

## DOM required nodes
- **DOCUMENT** is the 1st level
- `<html>` is the 2nd level
- `<head>` and `<body>` are co-equal third levels

## Nodes
- a **node** is the generic name for any type of object in the DOM hierarchy
- a **node** is any DOM object
- nodes are units of the DOM
- the **document** node is the top level
- element nodes are `<html>, <head>, <body>, <title>, <div> and <p>`
- text nodes are the strings that comprise the title and the two paragraphs
- each node is enclosed withing another node (except **document**) = it is a **child**
- `<head>` and `<body>` are **siblings** because they have a common parent `<html>`

```html
<!--this example consists of 5 nodes (div, h3, heading text, p, paragraph text)-->
<div>
  <h3>Age-old problem</h3>
  <p>
    So many nodes, so little time.
  </p>
</div> 
```
```html
<!-- <em> is a parent of the text node "important"-->
<p>This is <em>important</em>!</p>
```
## Targetting child nodes
- there is another approach of getting a desired node besides with ids and tags
Consider you want to "read" the second text node of the second `<div>` element node
```html
<body>
    <div id="cal">
        <p>Southern Cal is sunny.</p>
        <p>Northern Cal is rainy.</p>
        <p>Eastern Cal is desert.</p>
    </div>
    <div id="ny">
        <p>Urban NY is crowded.</p>
        <p>Rural NY is sparse.</p>
    </div>
</body>
```
```js
// we target it by selecting a second child of this div
const d = document.getElementById('ny');
const p = d.childNodes[1];
const contents = p.innerHTML;
```
## Junk artifacts and nodeType
- most browsers interpret the whitespace used to format the code as text nodes = junk artifacts
- Mozilla recommends to avoid it by doing something like this:
```html
<
p
>
```
- another solution to this is to use JS to recognize a type of a node:
```js
// this returns a number
const nType = targetNode.nodeType;
// element nodes are 1
// text nodes are 3
```

### How to filter out junk artifact (fake nodes)
We want to make sure we change a text node enclosed within the 2nd paragraph
```html
<div id="humpty">
    <p>All the king's horses.</p>
    <p>All the dude's crew.</p>
    <p>All the town's orthopedists.</p>
</div>
<a href="#" onClick="changeTextNode(); return false;">click</a>
```
We write a for loop that counts only which paragraph it is looping over
```js
function changeTextNode() {
    const myDiv = document.getElementById('humpty');
    let parCounter = 0;
    for (let i = 0; i < myDiv.childNodes.length; i++) {
        if (myDiv.childNodes[i].nodeType === 1) {
            parCounter++;
        }
        if (parCounter === 2) {
            myDiv.childNodes[i].innerHTML = 'All his men';    
        }
    }
}
```

## More ways to target elements
- `childNodes[0]` can be replaced by `firstChild`
- `childNodes[9]` from 10 children can be replaced by `lastChild`
- in the collection of an element's children we can target next child by `nextSibling`
- we can target the previous child by `previousSibling`
- it is recommended to **assign an id** to any node you might want to read with JS to avoid junk artifacts problems

```js
// we can also target a parent node from children if needed
const kidNode = document.getElementById('div2');
const pNode = kidNode.parentNode;

// we can combine special attributes
const nextToLast = par.lastChild.previousSibling;
const secondNode = par1.nextSibling;
```
## Getting a target's name
When we have targeted a node, we can read its attributes like:
- `nodeType`
- `nodeName`
- `nodeValue`

- node name are usually given in **all-caps**, even if the markup is lowercase
- node names are P for `<p> or <P>`, DIV for `<div> or <DIV>`, IMG for `<img> or <IMG> etc.
- node name of a text node is always lower-case `#text`
- element nodes have a name (.nodeName) but no value (.nodeValue return `null`)
- only text nodes have a value (.nodeValue)
- node types are **1 for an element node, 3 for a text node**
- when writing tests for nodeName, always convert `targetNode.nodeName.toLowerCase`
- keep in mind that `.innerHTML` is a property of an element node and a node value is a property of a text node itself
- `.innerHTML` includes all the descendants of the element

```html
<div id="div1">
  <div id="div2">
    <p>Chicago</p>
    <p>Kansas City</p>
    <p>St. Louis</p>
  </div>
</div>
```
```js
const firstDiv = document.getElementById("div1");
const secondDiv = firstDiv.childNodes[1]; // skipping junk artifact - carriage return at childNodes[0]
const firstPar = secondDiv.childNodes[1]; // skipping junk artifact - carriage return at childNodes[0]
const firstTextNode = firstPar.childNodes[0]; // at last, first next node - Chicago (.firstChild also works)
const secondCity = firstTextNode.nodeValue; // and the value of the text node
alert(secondCity);
```

